import { useQuery } from '@apollo/client';
import { useAccount, useBalance, useReadContract } from 'wagmi';
import { formatEther } from 'viem';
import { useState, useEffect, useCallback, useMemo } from 'react';

import { CONTRACTS, YD_TOKEN_ABI } from '../lib/contracts';
import {
  GET_USER_BALANCE,
  GET_USER_TOKEN_TRANSACTIONS,
  GET_USER_COURSE_PURCHASES,
  CHECK_COURSE_PURCHASE,
  GET_USER_TOKEN_TRANSFERS,
  GET_PLATFORM_STATS,
  GET_RECENT_ACTIVITY,
  GET_INSTRUCTOR_STATS,
  GET_COURSE_PURCHASES,
  GET_USER_BALANCE_HISTORY,
  GET_MARKET_OVERVIEW,
  GET_ANALYTICS_DATA,
} from '../lib/graphql-queries';
import {
  handleGraphError,
  checkGraphHealth,
  type TokenPurchase,
  type TokenSale,
  type CoursePurchase,
  type TokenTransfer,
  type UserTokenBalance,
} from '../lib/graph-client';

// üöÄ Êô∫ËÉΩ‰ΩôÈ¢ùÊü•ËØ¢ hook - Ê∑∑ÂêàÁ≠ñÁï•ÁöÑÊ†∏ÂøÉÂÆûÁé∞
export function useSmartBalance(forceRPC = false) {
  const { address } = useAccount();
  const [isGraphHealthy, setIsGraphHealthy] = useState(true);
  const [strategy, setStrategy] = useState<'graph' | 'rpc' | 'hybrid'>('hybrid');

  // üî¥ RPC Êü•ËØ¢ (ÂøÖÈ°ª‰øùÊåÅÁî®‰∫é‰∫§ÊòìÂâçÈ™åËØÅ)
  const { 
    data: ethBalance, 
    isLoading: ethLoading, 
    refetch: refetchETH 
  } = useBalance({
    address,
    query: {
      enabled: !!address,
      staleTime: forceRPC ? 0 : 10000, // ‰∫§ÊòìÂâçÂº∫Âà∂ÂÆûÊó∂Êü•ËØ¢
      refetchInterval: forceRPC ? false : 30000,
    },
  });

  const { 
    data: ydRPCBalance, 
    isLoading: ydRPCLoading, 
    refetch: refetchYDRPC 
  } = useReadContract({
    address: CONTRACTS.YDToken,
    abi: YD_TOKEN_ABI,
    functionName: 'balanceOf',
    args: address ? [address] : undefined,
    query: {
      enabled: !!address,
      staleTime: forceRPC ? 0 : 10000,
      refetchInterval: forceRPC ? false : 30000,
    },
  });

  // üü¢ The Graph Êü•ËØ¢ (Áî®‰∫é‰∏ÄËà¨ÊµèËßà)
  const { 
    data: graphData, 
    loading: graphLoading, 
    error: graphError,
    refetch: refetchGraph 
  } = useQuery(GET_USER_BALANCE, {
    variables: { userAddress: address?.toLowerCase() || '' },
    skip: !address || forceRPC,
    pollInterval: isGraphHealthy ? 30000 : 0,
    errorPolicy: 'all',
    fetchPolicy: forceRPC ? 'no-cache' : 'cache-first',
  });

  // ÂÅ•Â∫∑Ê£ÄÊü• The Graph
  useEffect(() => {
    if (!forceRPC) {
      checkGraphHealth().then(setIsGraphHealthy);
    }
  }, [forceRPC]);

  // Êô∫ËÉΩÁ≠ñÁï•ÈÄâÊã©
  const determineStrategy = useCallback(() => {
    if (forceRPC) return 'rpc';
    if (!isGraphHealthy || graphError) return 'rpc';
    if (graphData?.userTokenBalance && !graphLoading) return 'graph';
    return 'hybrid';
  }, [forceRPC, isGraphHealthy, graphError, graphData, graphLoading]);

  useEffect(() => {
    setStrategy(determineStrategy());
  }, [determineStrategy]);

  // üéØ Êô∫ËÉΩÊï∞ÊçÆÈÄâÊã©ÈÄªËæë
  const smartBalance = useMemo(() => {
    const result = {
      eth: {
        value: ethBalance?.value || 0n,
        formatted: ethBalance ? formatEther(ethBalance.value) : '0',
        source: 'rpc' as const,
      },
      yd: {
        value: 0n,
        formatted: '0',
        source: 'rpc' as const,
        lastUpdated: undefined as string | undefined,
      },
      strategy,
      isRealtime: forceRPC || strategy === 'rpc',
    };

    // YD Token ‰ΩôÈ¢ùÈÄâÊã©ÈÄªËæë
    switch (strategy) {
      case 'rpc':
        result.yd = {
          value: ydRPCBalance || 0n,
          formatted: ydRPCBalance ? formatEther(ydRPCBalance) : '0',
          source: 'rpc',
          lastUpdated: undefined,
        };
        break;
        
      case 'graph':
        const graphBalance = graphData?.userTokenBalance;
        result.yd = {
          value: graphBalance?.balance ? BigInt(graphBalance.balance) : 0n,
          formatted: graphBalance?.balance ? formatEther(BigInt(graphBalance.balance)) : '0',
          source: 'graph',
          lastUpdated: graphBalance?.lastUpdated,
        };
        break;
        
      case 'hybrid':
        // ‰ºòÂÖà‰ΩøÁî® RPCÔºåfallback Âà∞ Graph
        if (ydRPCBalance !== undefined) {
          result.yd = {
            value: ydRPCBalance,
            formatted: formatEther(ydRPCBalance),
            source: 'rpc',
            lastUpdated: undefined,
          };
        } else if (graphData?.userTokenBalance) {
          const graphBalance = graphData.userTokenBalance;
          result.yd = {
            value: BigInt(graphBalance.balance),
            formatted: formatEther(BigInt(graphBalance.balance)),
            source: 'graph',
            lastUpdated: graphBalance.lastUpdated,
          };
        }
        break;
    }

    return result;
  }, [ethBalance, ydRPCBalance, graphData, strategy, forceRPC]);

  const refetchAll = useCallback(() => {
    refetchETH();
    refetchYDRPC();
    if (!forceRPC) {
      refetchGraph();
    }
  }, [refetchETH, refetchYDRPC, refetchGraph, forceRPC]);

  return {
    ...smartBalance,
    isLoading: ethLoading || (strategy === 'rpc' ? ydRPCLoading : graphLoading),
    error: graphError ? handleGraphError(graphError) : null,
    refetch: refetchAll,
    isGraphHealthy,
  };
}

// üü¢ È´ò‰ºòÂÖàÁ∫ßÊõøÊç¢ - Áî®Êà∑‰∫§ÊòìÂéÜÂè≤ (The Graph)
export function useTokenTransactionHistory(first = 20, skip = 0) {
  const { address } = useAccount();
  
  const { data, loading, error, fetchMore } = useQuery(GET_USER_TOKEN_TRANSACTIONS, {
    variables: { 
      userAddress: address?.toLowerCase() || '', 
      first, 
      skip 
    },
    skip: !address,
    errorPolicy: 'all',
  });

  // ÂêàÂπ∂Âπ∂ÊéíÂ∫è‰∫§ÊòìËÆ∞ÂΩï
  const transactions = useMemo(() => {
    const purchases = (data?.tokenPurchases || []).map((tx: TokenPurchase) => ({
      ...tx,
      type: 'purchase' as const,
      amount: tx.tokenAmount,
    }));
    
    const sales = (data?.tokenSales || []).map((tx: TokenSale) => ({
      ...tx,
      type: 'sale' as const,
      amount: tx.tokenAmount,
    }));

    return [...purchases, ...sales]
      .sort((a, b) => parseInt(b.blockTimestamp) - parseInt(a.blockTimestamp));
  }, [data]);

  const loadMore = useCallback(() => {
    fetchMore({
      variables: { skip: transactions.length },
    });
  }, [fetchMore, transactions.length]);

  return {
    transactions,
    purchases: data?.tokenPurchases || [],
    sales: data?.tokenSales || [],
    isLoading: loading,
    error: error ? handleGraphError(error) : null,
    loadMore,
    hasMore: transactions.length >= first,
  };
}

// üü¢ È´ò‰ºòÂÖàÁ∫ßÊõøÊç¢ - ËØæÁ®ãË¥≠‰π∞ËÆ∞ÂΩïÊü•ËØ¢ (The Graph)
export function useCoursePurchaseHistory() {
  const { address } = useAccount();
  
  const { data, loading, error, refetch } = useQuery(GET_USER_COURSE_PURCHASES, {
    variables: { userAddress: address?.toLowerCase() || '' },
    skip: !address,
    pollInterval: 60000, // 1ÂàÜÈíüËΩÆËØ¢
  });

  return {
    purchases: (data?.coursePurchaseds || []) as CoursePurchase[],
    isLoading: loading,
    error: error ? handleGraphError(error) : null,
    refetch,
  };
}

// üî¥ ÂøÖÈ°ª‰øùÊåÅ RPC - ‰∫§ÊòìÂâçÁöÑ‰ΩôÈ¢ùÈ™åËØÅ
export function useTransactionBalance() {
  return useSmartBalance(true); // Âº∫Âà∂‰ΩøÁî® RPC
}

// üü° Ê∑∑ÂêàÁ≠ñÁï• - ËØæÁ®ãË¥≠‰π∞Áä∂ÊÄÅÊ£ÄÊü•
export function useCoursePurchaseStatus(courseId?: number) {
  const { address } = useAccount();
  
  // ÂÖàÁî® Graph Ê£ÄÊü•
  const { data: graphData, loading: graphLoading, error: graphError } = useQuery(CHECK_COURSE_PURCHASE, {
    variables: { 
      userAddress: address?.toLowerCase() || '',
      courseId: courseId?.toString() || ''
    },
    skip: !address || !courseId,
  });

  // üî¥ Â¶ÇÊûúÈúÄË¶ÅÂáÜÁ°ÆÊÄßÔºåÂèØ‰ª•Ê∑ªÂä† RPC È™åËØÅ
  // const { data: rpcData } = useReadContract({...});

  const hasPurchased = (graphData?.coursePurchaseds?.length || 0) > 0;
  const purchaseInfo = graphData?.coursePurchaseds?.[0];

  return {
    hasPurchased,
    purchaseInfo,
    isLoading: graphLoading,
    error: graphError ? handleGraphError(graphError) : null,
  };
}

// üü¢ È´ò‰ºòÂÖàÁ∫ßÊõøÊç¢ - Âπ≥Âè∞ÁªüËÆ°Êï∞ÊçÆ (The Graph)
export function usePlatformStats() {
  const { data, loading, error, refetch } = useQuery(GET_PLATFORM_STATS, {
    pollInterval: 60000, // ÊØèÂàÜÈíüËΩÆËØ¢
    errorPolicy: 'all',
  });

  const stats = useMemo(() => {
    if (!data) return null;

    return {
      token: data.ydtoken?.[0],
      totalPurchases: data.tokenPurchases?.length || 0,
      totalSales: data.tokenSales?.length || 0,
      totalCoursePurchases: data.coursePurchaseds?.length || 0,
      totalCourses: data.courseCreateds?.length || 0,
      totalInstructors: data.instructorApproveds?.length || 0,
      totalVolume: {
        eth: data.tokenPurchases?.reduce((sum: number, tx: TokenPurchase) => 
          sum + parseFloat(formatEther(BigInt(tx.ethAmount))), 0
        ) || 0,
        yd: data.tokenPurchases?.reduce((sum: number, tx: TokenPurchase) => 
          sum + parseFloat(formatEther(BigInt(tx.tokenAmount))), 0
        ) || 0,
      },
      courseRevenue: data.coursePurchaseds?.reduce((sum: number, tx: CoursePurchase) => 
        sum + parseFloat(formatEther(BigInt(tx.price))), 0
      ) || 0,
    };
  }, [data]);

  return {
    stats,
    isLoading: loading,
    error: error ? handleGraphError(error) : null,
    refetch,
  };
}

// üü¢ ÊúÄËøëÊ¥ªÂä® (The Graph)
export function useRecentActivity(first = 10) {
  const { data, loading, error, refetch } = useQuery(GET_RECENT_ACTIVITY, {
    variables: { first },
    pollInterval: 30000,
  });

  const activities = useMemo(() => {
    if (!data) return [];

    return [
      ...(data.recentTokenPurchases || []).map((activity: any) => ({
        ...activity,
        type: 'token_purchase',
      })),
      ...(data.recentCoursePurchases || []).map((activity: any) => ({
        ...activity,
        type: 'course_purchase',
      })),
      ...(data.recentCourses || []).map((activity: any) => ({
        ...activity,
        type: 'course_created',
      })),
    ].sort((a, b) => parseInt(b.blockTimestamp) - parseInt(a.blockTimestamp));
  }, [data]);

  return {
    activities,
    tokenPurchases: data?.recentTokenPurchases || [],
    coursePurchases: data?.recentCoursePurchases || [],
    coursesCreated: data?.recentCourses || [],
    isLoading: loading,
    error: error ? handleGraphError(error) : null,
    refetch,
  };
}

// üü¢ ËÆ≤Â∏àÁªüËÆ° (The Graph)
export function useInstructorStats(instructorAddress?: string) {
  const { address } = useAccount();
  const targetAddress = instructorAddress || address;
  
  const { data, loading, error, refetch } = useQuery(GET_INSTRUCTOR_STATS, {
    variables: { instructorAddress: targetAddress?.toLowerCase() || '' },
    skip: !targetAddress,
  });

  const stats = useMemo(() => {
    if (!data) return null;

    return {
      coursesCreated: data.courseCreateds?.length || 0,
      totalSales: data.coursePurchaseds?.length || 0,
      totalRevenue: data.coursePurchaseds?.reduce((sum: number, sale: CoursePurchase) => 
        sum + parseFloat(formatEther(BigInt(sale.price))), 0
      ) || 0,
      courses: data.courseCreateds || [],
      sales: data.coursePurchaseds || [],
    };
  }, [data]);

  return {
    stats,
    isLoading: loading,
    error: error ? handleGraphError(error) : null,
    refetch,
  };
}

// üöÄ Êñ∞Â¢ûÔºö‰ΩôÈ¢ùË∂ãÂäøÂàÜÊûê (The Graph)
export function useBalanceHistory(days = 7) {
  const { address } = useAccount();
  const since = Math.floor(Date.now() / 1000) - (days * 24 * 60 * 60);
  
  const { data, loading, error } = useQuery(GET_USER_BALANCE_HISTORY, {
    variables: { 
      userAddress: address?.toLowerCase() || '',
      since: since.toString()
    },
    skip: !address,
  });

  const balanceHistory = useMemo(() => {
    if (!data) return [];

    // ËÆ°ÁÆó‰ΩôÈ¢ùÂèòÂåñÂéÜÂè≤
    let runningBalance = 0n;
    const changes: Array<{
      timestamp: string;
      balance: string;
      change: string;
      type: 'purchase' | 'sale' | 'transfer_in' | 'transfer_out';
    }> = [];

    // ÂêàÂπ∂ÊâÄÊúâ‰∫§ÊòìÂπ∂ÊåâÊó∂Èó¥ÊéíÂ∫è
    const allTransactions = [
      ...data.tokenPurchases.map((tx: any) => ({ ...tx, type: 'purchase', amount: tx.tokenAmount })),
      ...data.tokenSales.map((tx: any) => ({ ...tx, type: 'sale', amount: tx.tokenAmount })),
      ...data.tokenTransfersReceived.map((tx: any) => ({ ...tx, type: 'transfer_in', amount: tx.value })),
      ...data.tokenTransfersSent.map((tx: any) => ({ ...tx, type: 'transfer_out', amount: tx.value })),
    ].sort((a, b) => parseInt(a.blockTimestamp) - parseInt(b.blockTimestamp));

    // ËÆ°ÁÆóÊØè‰∏™Êó∂Èó¥ÁÇπÁöÑ‰ΩôÈ¢ù
    allTransactions.forEach((tx) => {
      const amount = BigInt(tx.amount);
      
      if (tx.type === 'purchase' || tx.type === 'transfer_in') {
        runningBalance += amount;
      } else {
        runningBalance -= amount;
      }

      changes.push({
        timestamp: tx.blockTimestamp,
        balance: formatEther(runningBalance),
        change: formatEther(amount),
        type: tx.type,
      });
    });

    return changes;
  }, [data]);

  return {
    balanceHistory,
    currentBalance: data?.userTokenBalance,
    isLoading: loading,
    error: error ? handleGraphError(error) : null,
  };
}

// üöÄ Êñ∞Â¢ûÔºöÂ∏ÇÂú∫Ê¶ÇËßà (The Graph)
export function useMarketOverview(timeframe = '24h') {
  const hours = timeframe === '24h' ? 24 : timeframe === '7d' ? 168 : 720; // 30d
  const since = Math.floor(Date.now() / 1000) - (hours * 60 * 60);

  const { data, loading, error } = useQuery(GET_MARKET_OVERVIEW, {
    variables: { timeframe: since.toString() },
    pollInterval: 60000,
  });

  const marketData = useMemo(() => {
    if (!data) return null;

    const purchases = data.recentPurchases || [];
    const sales = data.recentSales || [];

    return {
      totalVolume: {
        eth: purchases.reduce((sum: number, tx: any) => 
          sum + parseFloat(formatEther(BigInt(tx.ethAmount))), 0
        ),
        yd: purchases.reduce((sum: number, tx: any) => 
          sum + parseFloat(formatEther(BigInt(tx.tokenAmount))), 0
        ),
      },
      transactionCount: purchases.length + sales.length,
      averagePrice: purchases.length > 0 ? 
        purchases.reduce((sum: number, tx: any) => 
          sum + (parseFloat(formatEther(BigInt(tx.ethAmount))) / parseFloat(formatEther(BigInt(tx.tokenAmount)))), 0
        ) / purchases.length : 0,
      priceChange: {}, // ÂèØ‰ª•ËÆ°ÁÆó‰ª∑Ê†ºÂèòÂåñ
      token: data.ydtoken?.[0],
    };
  }, [data]);

  return {
    marketData,
    isLoading: loading,
    error: error ? handleGraphError(error) : null,
  };
}

// üéØ ‰ΩøÁî®ÊåáÂçó Hook - Â∏ÆÂä©ÂºÄÂèëËÄÖÈÄâÊã©Ê≠£Á°ÆÁöÑÁ≠ñÁï•
export function useQueryStrategy() {
  return {
    // üü¢ Êé®Ëçê‰ΩøÁî® The Graph ÁöÑÂú∫ÊôØ
    forBrowsing: {
      balance: () => useSmartBalance(false),
      transactions: useTokenTransactionHistory,
      courseHistory: useCoursePurchaseHistory,
      platformStats: usePlatformStats,
      recentActivity: useRecentActivity,
      instructorStats: useInstructorStats,
      balanceHistory: useBalanceHistory,
      marketOverview: useMarketOverview,
    },
    
    // üî¥ ÂøÖÈ°ª‰ΩøÁî® RPC ÁöÑÂú∫ÊôØ
    forTransactions: {
      balance: () => useTransactionBalance(),
      // writeContract Áõ∏ÂÖ≥ÁöÑ hooks ‰øùÊåÅÁé∞ÊúâÂÆûÁé∞
    },
    
    // üü° Ê∑∑ÂêàÁ≠ñÁï•ÁöÑÂú∫ÊôØ
    forValidation: {
      coursePurchase: useCoursePurchaseStatus,
    },
  };
}
